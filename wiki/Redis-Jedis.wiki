#summary Investigating the Redis/Jedis implementation of the GL Service.

Contents:
<wiki:toc/>

=Introduction=

Redis/Jedis are one of the 4 storage possibilities currently being evaluated for use in the GL Service.

The others include:
 * [Cache Cache]
 * [JDBC JDBC]
 * [Voldemort Voldemort]

The core function of the GL Service is to store, retrive, and persist GL Strings; looking up GLResources by IDs and IDs by GL Strings. 
As such, three major parts of the GL Service are impacted by this storage option:
 * GlStringResolver
 * IdResolver
 * [GLRegistry GLRegistry]

=Details=

==Components==

The following classes are _part_ of the Redis/Jedis implementations:
|| *Name* || *Function* ||
|| [http://code.google.com/p/genotype-list/source/browse/trunk/gl-service/src/main/java/org/immunogenomics/gl/service/GlstringResolver.java GlstringResolver.java] || GlStringResolver interface ||
|| [http://code.google.com/p/genotype-list/source/browse/trunk/gl-service-redis/src/main/java/org/immunogenomics/gl/service/redis/JedisGlstringResolver.java JedisGlstringResolver.java] || Redis-Jedis implementation of the GlStringResolver ||
|| [http://code.google.com/p/genotype-list/source/browse/trunk/gl-service/src/main/java/org/immunogenomics/gl/service/IdResolver.java IdResolver.java] || IdResolver interface ||
|| [http://code.google.com/p/genotype-list/source/browse/trunk/gl-service-redis/src/main/java/org/immunogenomics/gl/service/redis/JedisIdResolver.java JedisIdResolver.java] || Redis-Jedis implementation of the IdResolver ||
|| [http://code.google.com/p/genotype-list/source/browse/trunk/gl-service/src/main/java/org/immunogenomics/gl/service/GlRegistry.java GlRegistry.java] || GLRegistry interface ||
|| [http://code.google.com/p/genotype-list/source/browse/trunk/gl-service-redis/src/main/java/org/immunogenomics/gl/service/redis/JedisGlRegistry.java JedisGlRegistry.java] || Redis-Jedis implementation of the GLRegistry ||

The following classes are _referenced_ by the Redis/Jedis implementations:
|| *Name* || *Function* ||
|| None || n/a ||

==About Redis/Jedis==

According to the [http://redis.io/ Redis website], "Redis is an open source, advanced key-value store. It is often referred to as a data structure server since keys can contain strings, hashes, lists, sets and sorted sets." Jedis is Redis' Java API.

Persistence is less of an issue with Redis/Jedis than with a standard in-memory cache - if an entry were to get overwritten it could be restored from a backup. According to [http://openmymind.net/redis.pdf _The Little Redis Book_], "Redis is an in-memory persistent store. With respect to persistence, by default, Redis snapshots the database to disk based on how many keys have changed. You configure it so that if X number of keys change, then save the database every Y seconds."

Redis/Jedis are currently a required Maven dependency for this project, and are conveniently located in the Maven Central Repository.

==!JedisGlstringResolver==

The !JedisGlstringResolver implements the interface GlStringResolver. The goal of the GlStringResolver is to take in a GL String and return its corresponding ID, or null if none is found.

With the Redis/Jedis implementation, the key is a non-empty, non-null GL String, with an ID for a value. Rather than maintaining separate caches for separate GL Resource types, the GL Resource type is prepended to the GL String. See below for an example. If no ID is found, the idSupplier is called.

The following is an example using the {{{Locus}}} [GLResources GL Resource]:

{{{
@Override
public String resolveLocus(final String glstring) {
    checkNotNull(glstring);
    checkArgument(!glstring.isEmpty());
    Jedis jedis = jedisPool.getResource();
    try {
        // prepend type to key since glstrings cannot uniquely identify type
        String uri = jedis.get("locus/" + glstring);
        if (uri != null) {
            return uri;
        }
    }
    finally {
        jedisPool.returnResource(jedis);
    }
    return idSupplier.createLocusId();
}
}}}

==!JedisIdResolver==

The !JedisIdResolver implements the interface IdResolver. The intent of the IdResolver is to take in an ID and return its corresponding [GLResources GL Resource], or null if none is found.

With the Redis/Jedis implementation, the key is an ID, and the [GLResources GL Resource] is the value. If no GL Resource is found, the method returns null.

The following is an example using the {{{Locus}}} [GLResources GL Resource]:

{{{
@Override
public Locus findLocus(final String id) {
    return (Locus) find(id);
}
}}}

==!JedisGlRegistry==

The !JedisGlRegistry implements the interface [GLRegistry GLRegistry]. The purpose of the [GLRegistry GLRegistry] is to enter [GLResources GL Resources] in the two caches (GL String -> ID and ID -> GL Resource) where they can be looked up by the GlStringResolver and IdResolver.

With the Redis/Jedis implementation, the entries are put into the cache using {{{set()}}} methods, in contrast to the {{{find()}}} methods used by the resolvers. The keys and values are extracted from the GL Resource as needed. 

The following is an example using the {{{Locus}}} [GLResources GL Resource]:

{{{
@Override
public void registerLocus(final Locus locus) {
    checkNotNull(locus);
    Jedis jedis = jedisPool.getResource();
    try {
        jedis.set(encode(locus.getId()), serialize(locus));
        // prepend type to key since glstrings cannot uniquely identify type
        jedis.set("locus/" + locus.getGlstring(), locus.getId());
    }
    finally {
        jedisPool.returnResource(jedis);
    }
}
}}}

=Performance Testing Results=

To be added after performance tests have been completed.
